import json
from collections import defaultdict
import logging
from webhelpers.text import truncate
import requests
from ckanext.datadotworld.model.extras import Extras
from ckanext.datadotworld.model import States
from ckan.lib.munge import munge_name
import ckan.model as model
from ckan.logic import get_action
import os.path
from markdown import markdown
from bleach import clean


log = logging.getLogger(__name__)
licenses = {
    'cc-by': 'CC-BY',
    'other-pd': 'Public Domain',
    'odc-pddl': 'PDDL',
    'cc-zero': 'CC-0',
    'odc-by': 'ODC-BY',
    'cc-by-sa': 'CC-BY-SA',
    'odc-odbl': 'ODC-ODbL',
    'cc-nc': 'CC BY-NC',
    # 'CC BY-NC-SA',
}


def get_context():
    return {'ignore_auth': True}


def dataworld_name(title):
    return munge_name(
        '-'.join(
            filter(
                None,
                filter(
                    None, ' '.join(title.split()).replace('_', '-')
                ).split('-')
            )
        )
    )


def _get_creds_if_must_sync(pkg_dict):
    owner_org = pkg_dict.get('owner_org')
    org = model.Group.get(owner_org)
    if org is None:
        return
    credentials = org.datadotworld_credentials
    if credentials is None or not credentials.integration:
        return
    return credentials


def notify(pkg_id):
    pkg_dict = get_action('package_show')(get_context(), {'id': pkg_id})
    if pkg_dict.get('type', 'dataset') != 'dataset':
        return
    credentials = _get_creds_if_must_sync(pkg_dict)
    if not credentials:
        return
    if pkg_dict.get('state') == 'draft':
        return
    api = API(credentials.owner, credentials.key)
    api.sync(pkg_dict)


def _prepare_resource_url(res):
    """Convert list of resources to files_list for data.world.
    """
    link = res['url']
    name = res['name']

    file, ext = os.path.splitext(os.path.basename(link))
    return dict(
        name=(name or file) + ext,
        source=dict(url=link)
    )


class API:
    root = 'https://data.world'
    api_root = 'https://api.data.world/v0'
    api_create = api_root + '/datasets/{owner}'
    api_update = api_create + '/{name}'
    api_res_create = api_update + '/files'
    api_res_sync = api_update + '/sync'
    api_res_update = api_res_create + '/{file}'
    api_res_delete = api_res_create + '/{file}'

    auth = 'Bearer {key}'

    def __init__(self, owner, key):
        """Initialize client with credentials.
        """
        self.owner = owner
        self.key = key

    def sync(self, pkg_dict):
        entity = model.Package.get(pkg_dict['id'])
        pkg_dict = get_action('package_show')(get_context(), {'id': entity.id})
        extras = entity.datadotworld_extras
        action = self._update if extras and extras.id else self._create
        if not extras:
            extras = Extras(package=entity, owner=self.owner)
            model.Session.add(extras)
        extras.state = States.pending
        try:
            model.Session.commit()
        except Exception as e:
            model.Session.rollback()
            log.warn('[sync problem] {0}'.format(e))

        action(pkg_dict, entity)
        model.Session.commit()

    def sync_resources(self, id):
        url = self.api_res_sync.format(
            owner=self.owner,
            name=id
        )
        resp = requests.get(url, headers=self._default_headers())
        msg = '{0} - {1:20} - {2}'.format(
            resp.status_code, id, resp.content
        )
        print(msg)
        log.info(msg)

    @classmethod
    def generate_link(cls, owner, package=None):
        url = cls.root + '/' + owner
        if package:
            url += '/' + package
        return url

    @classmethod
    def creds_from_id(cls, org_id):
        org = model.Group.get(org_id)
        if not org:
            return
        return org.datadotworld_credentials

    def check_credentials(self):
        headers = self._default_headers()
        url = self.api_update.format(
            owner=self.owner,
            name='definitely-fake-dataset-name'
        )
        resp = requests.get(url, headers=headers)

        if resp.status_code == 401:
            return False
        return True

    def _default_headers(self):
        return {
            'Authorization': self.auth.format(key=self.key),
            'Content-type': 'application/json'
        }

    def _create(self, pkg_dict, entity):
        data = self._format_data(pkg_dict)
        extras = entity.datadotworld_extras
        extras.id = dataworld_name(data['title'])
        headers = self._default_headers()
        url = self.api_create.format(owner=self.owner)
        res = requests.post(url, data=json.dumps(data), headers=headers)
        extras.message = res.content
        if res.status_code < 300:
            resp_json = res.json()
            if 'uri' in resp_json:
                new_id = os.path.basename(resp_json['uri'])
                log.info('Autogenerated ID: {0}; Remote ID: {1}'.format(
                    extras.id,
                    new_id
                ))
                extras.id = new_id

            extras.state = States.uptodate
        elif res.status_code == 400:
            log.warn('[create] Try to replace {id}'.format(id=extras.id))
            url = self.api_update.format(owner=self.owner, name=extras.id)
            remote_res = requests.put(url, data=json.dumps(data), headers=headers)
            extras.message = remote_res.content
            if remote_res.status_code == 200:
                extras.state = States.uptodate
            else:
                extras.state = States.failed
                log.error('[create {id}] Replace error:'.format(
                    id=extras.id) + remote_res.content)
                log.error('[create {id}]'.format(id=extras.id) + res.content)
        else:
            extras.state = States.failed
            log.error('[create {id}]'.format(id=extras.id) + res.content)

        return data

    def _update(self, pkg_dict, entity):
        data = self._format_data(pkg_dict)
        extras = entity.datadotworld_extras

        headers = self._default_headers()
        url = self.api_update.format(owner=self.owner, name=extras.id)
        remote_res = requests.get(url, headers=headers)
        if remote_res.status_code != 200:
            log.warn('[update {0}]Unable to get remote: {1}'.format(
                extras.id, remote_res.content))
        else:
            remote_data = remote_res.json()
            for key, value in data.items():
                if remote_data.get(key) != value:
                    break
            else:
                return

        res = requests.put(url, data=json.dumps(data), headers=headers)
        extras.message = res.content

        if res.status_code == 404:
            log.warn('[update {0}] Package not exists. Creating...')
            url = self.api_create.format(owner=self.owner)
            res = requests.post(url, data=json.dumps(data), headers=headers)
            if res.status_code == 200:
                log.info('Successfuly created')
            else:
                log.error('Create package:' + res.content)
        elif res.status_code >= 400:
            extras.state = States.failed
            log.error('Update package:' + res.content)
        else:
            extras.state = States.uptodate
        return data

    def _format_data(self, pkg_dict):
        tags = []
        notes = pkg_dict.get('notes') or ''
        description = truncate(
            clean(markdown(notes), tags=[], strip=True),
            120)
        for tag in pkg_dict.get('tags', []):
            tags.append(tag['name'])
        data = dict(
            title=pkg_dict['title'],
            description=description,
            summary=notes,
            tags=list(set(tags)),
            license=licenses.get(pkg_dict.get('license_id'), 'Other'),
            visibility='PRIVATE' if pkg_dict.get('private') else 'OPEN',
            files=[
                _prepare_resource_url(res)
                for res in pkg_dict['resources']
            ]
        )

        return data
