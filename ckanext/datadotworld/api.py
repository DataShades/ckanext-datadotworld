import json
import os.path
import logging

import requests
from bleach import clean
from markdown import markdown
from webhelpers.text import truncate

import ckan.model as model
from ckan.logic import get_action
from ckan.lib.munge import munge_name

from ckanext.datadotworld.model import States
from ckanext.datadotworld.model.extras import Extras


log = logging.getLogger(__name__)
licenses = {
    'cc-by': 'CC-BY',
    'other-pd': 'Public Domain',
    'odc-pddl': 'PDDL',
    'cc-zero': 'CC-0',
    'odc-by': 'ODC-BY',
    'cc-by-sa': 'CC-BY-SA',
    'odc-odbl': 'ODC-ODbL',
    'cc-nc': 'CC BY-NC',
    # 'CC BY-NC-SA',
}


def get_context():
    return {'ignore_auth': True}


def dataworld_name(title):
    cleaned_title = ' '.join(str.split()).replace('_', '-')
    return munge_name(
        '-'.join(filter(None, cleaned_title.split('-')))
    )


def _get_creds_if_must_sync(pkg_dict):
    owner_org = pkg_dict.get('owner_org')
    org = model.Group.get(owner_org)
    if org is None:
        return
    credentials = org.datadotworld_credentials
    if credentials is None or not credentials.integration:
        return
    return credentials


def notify(pkg_id):
    pkg_dict = get_action('package_show')(get_context(), {'id': pkg_id})
    if pkg_dict.get('type', 'dataset') != 'dataset':
        return
    credentials = _get_creds_if_must_sync(pkg_dict)
    if not credentials:
        return
    if pkg_dict.get('state') == 'draft':
        return
    api = API(credentials.owner, credentials.key)
    api.sync(pkg_dict)


def _prepare_resource_url(res):
    """Convert list of resources to files_list for data.world.
    """
    link = res['url']
    name = res['name']

    file, ext = os.path.splitext(os.path.basename(link))
    return dict(
        name=(name or file) + ext,
        source=dict(url=link)
    )


class API:
    root = 'https://data.world'
    api_root = 'https://api.data.world/v0'
    api_create = api_root + '/datasets/{owner}'
    api_update = api_create + '/{name}'
    api_res_create = api_update + '/files'
    api_res_sync = api_update + '/sync'
    api_res_update = api_res_create + '/{file}'
    api_res_delete = api_res_create + '/{file}'

    auth = 'Bearer {key}'

    @classmethod
    def generate_link(cls, owner, package=None):
        """Create link to data.world dataset.
        """
        parts = [cls.root, owner]
        if package:
            parts.append(package)
        return '/'.join(parts)

    @staticmethod
    def creds_from_id(org_id):
        """Find data.world credentials by org id.
        """
        org = model.Group.get(org_id)
        if not org:
            return
        return org.datadotworld_credentials

    def __init__(self, owner, key):
        """Initialize client with credentials.
        """
        self.owner = owner
        self.key = key

    def _default_headers(self):
        return {
            'Authorization': self.auth.format(key=self.key),
            'Content-type': 'application/json'
        }

    def _get(self, url):
        """Simple wrapper around GET request.
        """
        headers = self._default_headers()
        return requests.get(url=url, headers=headers)

    def _post(self, url, data):
        """Simple wrapper around POST request.
        """
        headers = self._default_headers()
        return requests.post(url=url, data=json.dumps(data), headers=headers)

    def _put(self, url, data):
        """Simple wrapper around PUT request.
        """
        headers = self._default_headers()
        return requests.put(url=url, data=json.dumps(data), headers=headers)

    def _format_data(self, pkg_dict):
        tags = []
        notes = pkg_dict.get('notes') or ''
        description = truncate(
            clean(markdown(notes), tags=[], strip=True),
            120)
        for tag in pkg_dict.get('tags', []):
            tags.append(tag['name'])
            data = dict(
                title=pkg_dict['title'],
                description=description,
                summary=notes,
                tags=list(set(tags)),
                license=licenses.get(pkg_dict.get('license_id'), 'Other'),
                visibility='PRIVATE' if pkg_dict.get('private') else 'OPEN',
                files=[
                    _prepare_resource_url(res)
                for res in pkg_dict['resources']
                ]
            )

        return data

    def _create(self, pkg_dict, entity):
        data = self._format_data(pkg_dict)
        extras = entity.datadotworld_extras
        extras.id = dataworld_name(data['title'])

        url = self.api_create.format(owner=self.owner)
        res = self._post(url, data)
        extras.message = res.content
        if res.status_code < 300:
            resp_json = res.json()
            if 'uri' in resp_json:
                new_id = os.path.basename(resp_json['uri'])
                log.info('Autogenerated ID: {0}; Remote ID: {1}'.format(
                    extras.id,
                    new_id
                ))
                extras.id = new_id

            extras.state = States.uptodate
        elif res.status_code == 400:
            log.warn('[create] Try to replace {id}'.format(id=extras.id))
            url = self.api_update.format(owner=self.owner, name=extras.id)
            remote_res = self._put(url, data)
            extras.message = remote_res.content
            if remote_res.status_code == 200:
                extras.state = States.uptodate
            else:
                extras.state = States.failed
                log.error('[create {id}] Replace error:'.format(
                    id=extras.id) + remote_res.content)
                log.error('[create {id}]'.format(id=extras.id) + res.content)
        else:
            extras.state = States.failed
            log.error('[create {id}]'.format(id=extras.id) + res.content)

        return data

    def _update(self, pkg_dict, entity):
        data = self._format_data(pkg_dict)
        extras = entity.datadotworld_extras

        url = self.api_update.format(owner=self.owner, name=extras.id)
        remote_res = self._get(url)
        if remote_res.status_code != 200:
            log.warn('[update {0}]Unable to get remote: {1}'.format(
                extras.id, remote_res.content))
        else:
            remote_data = remote_res.json()
            for key, value in data.items():
                if remote_data.get(key) != value:
                    break
            else:
                return

        res = self._put(url, data)
        extras.message = res.content

        if res.status_code == 404:
            log.warn('[update {0}] Package not exists. Creating...')
            url = self.api_create.format(owner=self.owner)
            res = self._post(url, data)
            if res.status_code == 200:
                log.info('Successfuly created')
            else:
                log.error('Create package:' + res.content)
        elif res.status_code >= 400:
            extras.state = States.failed
            log.error('Update package:' + res.content)
        else:
            extras.state = States.uptodate
        return data

    def sync(self, pkg_dict):
        entity = model.Package.get(pkg_dict['id'])
        pkg_dict = get_action('package_show')(get_context(), {'id': entity.id})
        extras = entity.datadotworld_extras
        action = self._update if extras and extras.id else self._create
        if not extras:
            extras = Extras(package=entity, owner=self.owner)
            model.Session.add(extras)
            extras.state = States.pending
        try:
            model.Session.commit()
        except Exception as e:
            model.Session.rollback()
            log.warn('[sync problem] {0}'.format(e))

        action(pkg_dict, entity)
        model.Session.commit()

    def sync_resources(self, id):
        url = self.api_res_sync.format(
            owner=self.owner,
            name=id
        )
        resp = self._get(url)
        msg = '{0} - {1:20} - {2}'.format(
            resp.status_code, id, resp.content
        )
        print(msg)
        log.info(msg)

    def check_credentials(self):
        url = self.api_update.format(
            owner=self.owner,
            name='definitely-fake-dataset-name'
        )
        resp = self._get(url)

        if resp.status_code == 401:
            return False
        return True
